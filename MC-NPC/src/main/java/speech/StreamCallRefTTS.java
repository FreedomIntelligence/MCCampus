package speech;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.msgpack.jackson.dataformat.MessagePackFactory;
import okhttp3.*;

import java.io.*;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.HashMap;
import java.util.Map;
import java.io.InputStream;
import javax.sound.sampled.*;

public class StreamCallRefTTS {
    private final AudioStreamPlayer audioPlayer;
    private String url;
    private String apiKey;
    private ObjectMapper msgPackMapper;
    private OkHttpClient client;
    private static final Logger LOGGER = Logger.getLogger(StreamCallRefTTS.class.getName());

    public StreamCallRefTTS(String url, String apiKey) {
        this.url = url;
        this.apiKey = apiKey;
        this.client = new OkHttpClient.Builder()
                .readTimeout(60, TimeUnit.SECONDS)  // 禁用读取超时
                .build();
        this.msgPackMapper = new ObjectMapper(new MessagePackFactory());
        this.audioPlayer = new AudioStreamPlayer();

    }

    public void StreamCall(String text,String ref_key) {
        try {
            Map<String, String> refAudioDict = new HashMap<>();
            refAudioDict.put("朱世平教授", "/home/sunzhu/Real-time-hyperpersonification/NPC_Ref_audio/采访声音/副校长（朱世平）.mp3<text>:对吧大家都知道，是可以的。但是我们也很同学们讲，这个呢，也是，我们说大学里面我们办些讲座，教教大家怎么谈恋爱。谈恋爱有很多规矩的，对不对啊，大家都知道哈，这个非常重要。就是谈恋爱也是一个学术性的东西，所以要。。要要有理论指导，所以呢学校呢以后也会准备一些这个这个呃，seminar，教大家一些基本的东西。我还建议，这个事情不能急，对哇，我是跟你讲，谈恋爱是一门艺术，需要好好琢磨。");
            refAudioDict.put("唐文方教授", "/home/sunzhu/Real-time-hyperpersonification/NPC_Ref_audio/采访声音/人文科学院院长（唐文方）.mp3<text>:我知道现在大家都非常辛苦，正在积极准备高考，我是，嗯，1977年文革以后第一次参加高考，我当时是，那个时候我的心情也非常紧张。但是我们那个时候考试的内容远比现在简单的多，你们现在要考的内容已经比我们当时的知识水平要高出很多很多，所以你们已经很棒了。我给大家的建议就是，高考的时候怎么克服紧张的情绪，是不要过多的去想结果。");
            refAudioDict.put("郑仲煊教授", "/home/sunzhu/Real-time-hyperpersonification/NPC_Ref_audio/采访声音/医学院院长（郑仲煊）en含背景声.mp3<text>:大家好，我是郑仲煊。AI technology is a wonderful question because there are so many in the AI integration. The AI, one of the most important integrations is using AI for doing risk prediction. Using AI for technology, for treatment of patients, able to very precisely doing the right decision treatment. As well, there are technologies for robotics and other multi-modules.");
            refAudioDict.put("戴建岗教授", "/home/sunzhu/Real-time-hyperpersonification/NPC_Ref_audio/采访声音/数据科学院院长(戴建岗)en.MP3<text>:We now live in a time of big data.The intelligent physicians generated by data and arithmetic have become an important component in our daily life.How to create value from secure，fair，data efficient algorithms has become an important challenge faces by every industry in our society.With such background,the school of data science at the Chinese university of Hong Kong,Shenzhen,is established on july fisrt，2020.");
            refAudioDict.put("徐扬生教授", "/home/sunzhu/Real-time-hyperpersonification/NPC_Ref_audio/采访声音/校长（徐扬生）.mp3<text>:我是经常跟同学在那里，额，打交道。我就发现，这个，如果有一个这个同学有点什么问题的话，他推来推去推事情，永远是跟人家要慢半拍的啊，拖拖拉拉的人，对不起，他背后一定有一个事无巨细、什么事情都要管的母亲在那里。我告诉你，我的观察爸爸妈妈两者的话，都有责任。家长在高考这 100 天当中最好的示范作用是什么。");
            refAudioDict.put("唐本忠教授", "/home/sunzhu/Real-time-hyperpersonification/NPC_Ref_audio/采访声音/理工学院院长（唐本忠）.mp3<text>:研究主要是与光有关系，我们看看这个摄影棚，我们就知道光对现代世界是非常非常重要的。从远古到现在，一直都很重要，但是现在的社会就更重要了，因为你现在的通讯是电子通讯，但是以后一定是光子通讯。那就与光有关系，这是从比较实用的角度来讲，我们现在做这个研究叫做聚集诱导发光，聚集诱导发光是什么呢，就是说聚集之后发光更强");
            refAudioDict.put("熊伟教授", "/home/sunzhu/Real-time-hyperpersonification/NPC_Ref_audio/采访声音/经管学院院长（熊伟).mp3<text>:经管的准毕业生同学们，时光飞逝，还有不到一年，你们即将从SME毕业，奔赴新的前程。为了帮助同学们在本科最后一年做好求职、求学的冲刺，SME CDC组织了本次的准毕业生沟通会。一方面，让大家思想上提个醒。充分利用接下来大半年的时间，做好每周每月的规划，一步一步落实到位，直到做到心仪的offer另一方面。通过分析当前求职求学的");
            refAudioDict.put("叶小钢教授", "/home/sunzhu/Real-time-hyperpersonification/NPC_Ref_audio/采访声音/音乐学院院长（叶小钢).mp3<text>:学生来说，他面临这个世界，我觉得判断和选择是最重要的。为什么，判断包括人生的，生活道路的判断，艺术道路的判断，对学习所用的教材的判断和选择都是非常重要的，这对学生的一生的影响是很大的，觉得大学这个环境培养了什么样的人最合适呢，我觉得每一位学生都应该认识到。我在大学里所要完成的任务是开拓事业，积极进取啊身体");




            String value = refAudioDict.get(ref_key);
            String[] parts = value.split("<text>:", 2); // 分成两个部分

            String ref_path = parts[0].trim();
            String ref_text = parts[1].trim();
            System.out.println("Reference Audio Path: " + ref_path);
            System.out.println("Reference Text: " + ref_text);
            List<ServeReferenceAudio> references = new ArrayList<>();

//            String ref_path = "/home/sunzhu/Real-time-hyperpersonification/NPC_Ref_audio/采访声音/副校长（朱世平）.mp3";
//            File refFile = new File(referencePath);
//            if (!refFile.exists()) {
//                LOGGER.log(Level.WARNING, "Reference audio file does not exist: " + referencePath);
//            }
//            String ref_text = "对吧大家都知道，是可以的。但是我们也很同学们讲，这个呢，也是，我们说大学里面我们办些讲座，教教大家怎么谈恋爱。谈恋爱有很多规矩的，对不对啊，大家都知道哈，这个非常重要。就是谈恋爱也是一个学术性的东西，所以要。。要要有理论指导，所以呢学校呢以后也会准备一些这个这个呃，seminar，教大家一些基本的东西。我还建议，这个事情不能急，对哇，我是跟你讲，谈恋爱是一门艺术，需要好好琢磨。";

            references.add(new ServeReferenceAudio(ref_path, ref_text));

            ServeTTSRequest request = new ServeTTSRequest();
            request.setText(text);
            request.setChunkLength(200);
            request.setFormat("wav");
            request.setMp3Bitrate(64);
            request.setReferences(references);
            request.setReferenceId(null);
            request.setNormalize(true);
            request.setOpusBitrate(-1000);
            request.setLatency("normal");
            request.setStreaming(true);
            request.setEmotion(null); // 如果有情感参数，需要设置具体的情感对象
            request.setMaxNewTokens(1024);
            request.setTopP(0.7);
            request.setRepetitionPenalty(1.2);
            request.setTemperature(0.7);

            byte[] requestBodyBytes = msgPackMapper.writeValueAsBytes(request);
            RequestBody requestBody = RequestBody.create(requestBodyBytes, MediaType.parse("application/msgpack"));
            Request httpRequest = new Request.Builder()
                    .url(this.url)
                    .header("Authorization", "Bearer " + this.apiKey)
                    .header("Content-Type", "application/msgpack")
                    .post(requestBody)
                    .build();

            Response response = null;

            client.newCall(httpRequest).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    e.printStackTrace();
                }

                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    if (!response.isSuccessful()) {
                        throw new IOException("Call Failed. Code " + response);
                    }

                    // 获取响应体的输入流
                    InputStream inputStream = response.body().byteStream();
                    byte[] firstBytes = new byte[1024];
                    int read = inputStream.read(firstBytes);
                    LOGGER.info("Read first " + read + " bytes from stream");

                    // 创建音频播放器并开始播放
                    try {
                        audioPlayer.playStream(inputStream);
                    } finally {
                        inputStream.close();
                        response.close();
                    }
                }
            });

        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error in generating speech: " + e.getMessage(), e);
        }
    }

    private class AudioStreamPlayer {
        private volatile boolean isPlaying = false;

        public void playStream(InputStream inputStream) {
            try {
                LOGGER.info("Starting to process audio stream");
                AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(
                        new BufferedInputStream(inputStream));
                AudioFormat format = audioInputStream.getFormat();
                LOGGER.info("Audio format: " + format.toString());

                DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);

                try (SourceDataLine line = (SourceDataLine) AudioSystem.getLine(info)) {
                    line.open(format);
                    line.start();

                    byte[] buffer = new byte[4096];
                    int bytesRead;
                    int totalBytesRead = 0;
                    isPlaying = true;

                    while (isPlaying && (bytesRead = audioInputStream.read(buffer)) != -1) {
                        line.write(buffer, 0, bytesRead);
                        totalBytesRead += bytesRead;
                    }
                    LOGGER.info("Finished playing. Total bytes: " + totalBytesRead);
                    line.drain();
                }
                System.out.println("Stream info:"+info);

            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public void stop() {
            isPlaying = false;
        }
    }

    class ServeReferenceAudio {
        private String audio;
        private String text;

        public ServeReferenceAudio(String audio, String text) {
            this.audio = audio;
            this.text = text;
        }

        public String getAudio() {
            return audio;
        }

        public void setAudio(String audio) {
            this.audio = audio;
        }

        public String getText() {
            return text;
        }

        public void setText(String text) {
            this.text = text;
        }
    }

    private static class ServeTTSRequest {
        private String text;
        private int chunkLength;
        private String format;
        private int mp3Bitrate;
        private List<ServeReferenceAudio> references;
        private String referenceId;
        private boolean normalize;
        private int opusBitrate;
        private String latency;
        private boolean streaming;
        private String emotion;
        private int maxNewTokens;
        private double topP;
        private double repetitionPenalty;
        private double temperature;

        // Constructor
        public ServeTTSRequest() {
        }

        // Getters and Setters
        public String getText() {
            return text;
        }

        public void setText(String text) {
            this.text = text;
        }

        public int getChunkLength() {
            return chunkLength;
        }

        public void setChunkLength(int chunkLength) {
            this.chunkLength = chunkLength;
        }

        public String getFormat() {
            return format;
        }

        public void setFormat(String format) {
            this.format = format;
        }

        public int getMp3Bitrate() {
            return mp3Bitrate;
        }

        public void setMp3Bitrate(int mp3Bitrate) {
            this.mp3Bitrate = mp3Bitrate;
        }

        public List<ServeReferenceAudio> getReferences() {
            return references;
        }

        public void setReferences(List<ServeReferenceAudio> references) {
            this.references = references;
        }

        public String getReferenceId() {
            return referenceId;
        }

        public void setReferenceId(String referenceId) {
            this.referenceId = referenceId;
        }

        public boolean isNormalize() {
            return normalize;
        }

        public void setNormalize(boolean normalize) {
            this.normalize = normalize;
        }

        public int getOpusBitrate() {
            return opusBitrate;
        }

        public void setOpusBitrate(int opusBitrate) {
            this.opusBitrate = opusBitrate;
        }

        public String getLatency() {
            return latency;
        }

        public void setLatency(String latency) {
            this.latency = latency;
        }

        public boolean isStreaming() {
            return streaming;
        }

        public void setStreaming(boolean streaming) {
            this.streaming = streaming;
        }

        public String getEmotion() {
            return emotion;
        }

        public void setEmotion(String emotion) {
            this.emotion = emotion;
        }

        public int getMaxNewTokens() {
            return maxNewTokens;
        }

        public void setMaxNewTokens(int maxNewTokens) {
            this.maxNewTokens = maxNewTokens;
        }

        public double getTopP() {
            return topP;
        }

        public void setTopP(double topP) {
            this.topP = topP;
        }

        public double getRepetitionPenalty() {
            return repetitionPenalty;
        }

        public void setRepetitionPenalty(double repetitionPenalty) {
            this.repetitionPenalty = repetitionPenalty;
        }

        public double getTemperature() {
            return temperature;
        }

        public void setTemperature(double temperature) {
            this.temperature = temperature;
        }
    }


}